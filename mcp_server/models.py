# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T09:41:07+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, List, Optional

from pydantic import BaseModel, Field, RootModel, conint, constr


class AccountId(RootModel[constr(min_length=12, max_length=12)]):
    root: constr(min_length=12, max_length=12)


class Arn(RootModel[str]):
    root: str


class AwsCloudMapInstanceAttributeKey(
    RootModel[constr(pattern=r'^[a-zA-Z0-9!-~]+$', min_length=1, max_length=255)]
):
    root: constr(pattern=r'^[a-zA-Z0-9!-~]+$', min_length=1, max_length=255)


class AwsCloudMapInstanceAttributeValue(
    RootModel[
        constr(
            pattern=r'^([a-zA-Z0-9!-~][  a-zA-Z0-9!-~]*){0,1}[a-zA-Z0-9!-~]{0,1}$',
            min_length=1,
            max_length=1024,
        )
    ]
):
    root: constr(
        pattern=r'^([a-zA-Z0-9!-~][  a-zA-Z0-9!-~]*){0,1}[a-zA-Z0-9!-~]{0,1}$',
        min_length=1,
        max_length=1024,
    )


class AwsCloudMapName(RootModel[constr(min_length=1, max_length=1024)]):
    root: constr(min_length=1, max_length=1024)


class BadRequestException(RootModel[Any]):
    root: Any


class Boolean(RootModel[bool]):
    root: bool


class CertificateAuthorityArns(RootModel[List[Arn]]):
    root: List[Arn] = Field(..., max_length=3, min_length=1)


class ConflictException(RootModel[Any]):
    root: Any


class DefaultGatewayRouteRewrite(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'


class DeleteGatewayRouteInput(BaseModel):
    pass


class DeleteMeshInput(BaseModel):
    pass


class DeleteRouteInput(BaseModel):
    pass


class DeleteVirtualGatewayInput(BaseModel):
    pass


class DeleteVirtualNodeInput(BaseModel):
    pass


class DeleteVirtualRouterInput(BaseModel):
    pass


class DeleteVirtualServiceInput(BaseModel):
    pass


class DescribeGatewayRouteInput(BaseModel):
    pass


class DescribeMeshInput(BaseModel):
    pass


class DescribeRouteInput(BaseModel):
    pass


class DescribeVirtualGatewayInput(BaseModel):
    pass


class DescribeVirtualNodeInput(BaseModel):
    pass


class DescribeVirtualRouterInput(BaseModel):
    pass


class DescribeVirtualServiceInput(BaseModel):
    pass


class DnsResponseType(Enum):
    LOADBALANCER = 'LOADBALANCER'
    ENDPOINTS = 'ENDPOINTS'


class DurationUnit(Enum):
    s = 's'
    ms = 'ms'


class DurationValue(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class EgressFilterType(Enum):
    ALLOW_ALL = 'ALLOW_ALL'
    DROP_ALL = 'DROP_ALL'


class ExactHostName(RootModel[constr(min_length=1, max_length=253)]):
    root: constr(min_length=1, max_length=253)


class FilePath(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class ForbiddenException(RootModel[Any]):
    root: Any


class GatewayRouteHostnameRewrite(BaseModel):
    defaultTargetHostname: Optional[DefaultGatewayRouteRewrite] = None


class GatewayRoutePriority(RootModel[conint(ge=0, le=1000)]):
    root: conint(ge=0, le=1000)


class GatewayRouteStatusCode(Enum):
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'
    DELETED = 'DELETED'


class GrpcGatewayRouteRewrite(BaseModel):
    hostname: Optional[GatewayRouteHostnameRewrite] = None


class GrpcRetryPolicyEvent(Enum):
    cancelled = 'cancelled'
    deadline_exceeded = 'deadline-exceeded'
    internal = 'internal'
    resource_exhausted = 'resource-exhausted'
    unavailable = 'unavailable'


class GrpcRetryPolicyEvents(RootModel[List[GrpcRetryPolicyEvent]]):
    root: List[GrpcRetryPolicyEvent] = Field(..., max_length=5, min_length=1)


class HeaderMatch(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class HeaderName(RootModel[constr(min_length=1, max_length=50)]):
    root: constr(min_length=1, max_length=50)


class HealthCheckIntervalMillis(RootModel[conint(ge=5000, le=300000)]):
    root: conint(ge=5000, le=300000)


class HealthCheckThreshold(RootModel[conint(ge=2, le=10)]):
    root: conint(ge=2, le=10)


class HealthCheckTimeoutMillis(RootModel[conint(ge=2000, le=60000)]):
    root: conint(ge=2000, le=60000)


class Hostname(RootModel[str]):
    root: str


class HttpGatewayRoutePrefix(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class HttpGatewayRoutePrefixRewrite(BaseModel):
    defaultPrefix: Optional[DefaultGatewayRouteRewrite] = None
    value: Optional[HttpGatewayRoutePrefix] = None


class HttpMethod(Enum):
    GET = 'GET'
    HEAD = 'HEAD'
    POST = 'POST'
    PUT = 'PUT'
    DELETE = 'DELETE'
    CONNECT = 'CONNECT'
    OPTIONS = 'OPTIONS'
    TRACE = 'TRACE'
    PATCH = 'PATCH'


class HttpPathExact(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class HttpPathRegex(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class HttpRetryPolicyEvent(RootModel[constr(min_length=1, max_length=25)]):
    root: constr(min_length=1, max_length=25)


class HttpRetryPolicyEvents(RootModel[List[HttpRetryPolicyEvent]]):
    root: List[HttpRetryPolicyEvent] = Field(..., max_length=25, min_length=1)


class HttpScheme(Enum):
    http = 'http'
    https = 'https'


class InternalServerErrorException(RootModel[Any]):
    root: Any


class IpPreference(Enum):
    IPv6_PREFERRED = 'IPv6_PREFERRED'
    IPv4_PREFERRED = 'IPv4_PREFERRED'
    IPv4_ONLY = 'IPv4_ONLY'
    IPv6_ONLY = 'IPv6_ONLY'


class JsonKey(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class JsonValue(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class LimitExceededException(RootModel[Any]):
    root: Any


class ListGatewayRoutesInput(BaseModel):
    pass


class ListGatewayRoutesLimit(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListMeshesInput(BaseModel):
    pass


class ListMeshesLimit(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListRoutesInput(BaseModel):
    pass


class ListRoutesLimit(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListTagsForResourceInput(BaseModel):
    pass


class ListVirtualGatewaysInput(BaseModel):
    pass


class ListVirtualGatewaysLimit(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListVirtualNodesInput(BaseModel):
    pass


class ListVirtualNodesLimit(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListVirtualRoutersInput(BaseModel):
    pass


class ListVirtualRoutersLimit(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListVirtualServicesInput(BaseModel):
    pass


class ListVirtualServicesLimit(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class ListenerPort(RootModel[conint(ge=1, le=65535)]):
    root: conint(ge=1, le=65535)


class ListenerTlsAcmCertificate(BaseModel):
    certificateArn: Arn


class ListenerTlsFileCertificate(BaseModel):
    certificateChain: FilePath
    privateKey: FilePath


class ListenerTlsMode(Enum):
    STRICT = 'STRICT'
    PERMISSIVE = 'PERMISSIVE'
    DISABLED = 'DISABLED'


class Long(RootModel[int]):
    root: int


class MatchRange(BaseModel):
    end: Long
    start: Long


class MaxConnections(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class MaxPendingRequests(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class MaxRequests(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class MaxRetries(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class MeshServiceDiscovery(BaseModel):
    ipPreference: Optional[IpPreference] = None


class MeshStatusCode(Enum):
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'
    DELETED = 'DELETED'


class MethodName(RootModel[constr(min_length=1, max_length=50)]):
    root: constr(min_length=1, max_length=50)


class NotFoundException(RootModel[Any]):
    root: Any


class OutlierDetectionMaxEjectionPercent(RootModel[conint(ge=0, le=100)]):
    root: conint(ge=0, le=100)


class OutlierDetectionMaxServerErrors(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class PercentInt(RootModel[conint(ge=0, le=100)]):
    root: conint(ge=0, le=100)


class PortNumber(RootModel[conint(ge=1, le=65535)]):
    root: conint(ge=1, le=65535)


class PortProtocol(Enum):
    http = 'http'
    tcp = 'tcp'
    http2 = 'http2'
    grpc = 'grpc'


class PortSet(RootModel[List[PortNumber]]):
    root: List[PortNumber]


class QueryParameterName(RootModel[str]):
    root: str


class ResourceInUseException(RootModel[Any]):
    root: Any


class ResourceName(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class RoutePriority(RootModel[conint(ge=0, le=1000)]):
    root: conint(ge=0, le=1000)


class RouteStatusCode(Enum):
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'
    DELETED = 'DELETED'


class SdsSecretName(RootModel[str]):
    root: str


class ServiceName(RootModel[str]):
    root: str


class ServiceUnavailableException(RootModel[Any]):
    root: Any


class String(RootModel[str]):
    root: str


class SubjectAlternativeName(RootModel[constr(min_length=1, max_length=254)]):
    root: constr(min_length=1, max_length=254)


class SubjectAlternativeNameList(RootModel[List[SubjectAlternativeName]]):
    root: List[SubjectAlternativeName]


class SubjectAlternativeNameMatchers(BaseModel):
    exact: SubjectAlternativeNameList


class SubjectAlternativeNames(BaseModel):
    match: SubjectAlternativeNameMatchers


class SuffixHostname(RootModel[constr(min_length=1, max_length=253)]):
    root: constr(min_length=1, max_length=253)


class TagKey(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class TagKeyList(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=50, min_length=0)


class TagResourceOutput(BaseModel):
    pass


class TagValue(RootModel[constr(min_length=0, max_length=256)]):
    root: constr(min_length=0, max_length=256)


class TagsLimit(RootModel[conint(ge=1, le=50)]):
    root: conint(ge=1, le=50)


class TcpRetryPolicyEvent(Enum):
    connection_error = 'connection-error'


class TcpRetryPolicyEvents(RootModel[List[TcpRetryPolicyEvent]]):
    root: List[TcpRetryPolicyEvent] = Field(..., max_length=1, min_length=1)


class TcpRouteMatch(BaseModel):
    port: Optional[ListenerPort] = None


class TextFormat(RootModel[constr(min_length=1, max_length=1000)]):
    root: constr(min_length=1, max_length=1000)


class Timestamp(RootModel[datetime]):
    root: datetime


class TlsValidationContextAcmTrust(BaseModel):
    certificateAuthorityArns: CertificateAuthorityArns


class TlsValidationContextFileTrust(BaseModel):
    certificateChain: FilePath


class TlsValidationContextSdsTrust(BaseModel):
    secretName: SdsSecretName


class TlsValidationContextTrust(BaseModel):
    acm: Optional[TlsValidationContextAcmTrust] = None
    file: Optional[TlsValidationContextFileTrust] = None
    sds: Optional[TlsValidationContextSdsTrust] = None


class TooManyRequestsException(RootModel[Any]):
    root: Any


class TooManyTagsException(RootModel[Any]):
    root: Any


class UntagResourceInput(BaseModel):
    tagKeys: TagKeyList


class UntagResourceOutput(BaseModel):
    pass


class VirtualGatewayCertificateAuthorityArns(RootModel[List[Arn]]):
    root: List[Arn] = Field(..., max_length=3, min_length=1)


class VirtualGatewayGrpcConnectionPool(BaseModel):
    maxRequests: MaxRequests


class VirtualGatewayHealthCheckIntervalMillis(RootModel[conint(ge=5000, le=300000)]):
    root: conint(ge=5000, le=300000)


class VirtualGatewayHealthCheckThreshold(RootModel[conint(ge=2, le=10)]):
    root: conint(ge=2, le=10)


class VirtualGatewayHealthCheckTimeoutMillis(RootModel[conint(ge=2000, le=60000)]):
    root: conint(ge=2000, le=60000)


class VirtualGatewayHttp2ConnectionPool(BaseModel):
    maxRequests: MaxRequests


class VirtualGatewayHttpConnectionPool(BaseModel):
    maxConnections: MaxConnections
    maxPendingRequests: Optional[MaxPendingRequests] = None


class VirtualGatewayListenerTlsAcmCertificate(BaseModel):
    certificateArn: Arn


class VirtualGatewayListenerTlsFileCertificate(BaseModel):
    certificateChain: FilePath
    privateKey: FilePath


class VirtualGatewayListenerTlsMode(Enum):
    STRICT = 'STRICT'
    PERMISSIVE = 'PERMISSIVE'
    DISABLED = 'DISABLED'


class VirtualGatewayPortProtocol(Enum):
    http = 'http'
    http2 = 'http2'
    grpc = 'grpc'


class VirtualGatewayRef(BaseModel):
    arn: Arn
    createdAt: Timestamp
    lastUpdatedAt: Timestamp
    meshName: ResourceName
    meshOwner: AccountId
    resourceOwner: AccountId
    version: Long
    virtualGatewayName: ResourceName


class VirtualGatewaySdsSecretName(RootModel[str]):
    root: str


class VirtualGatewayStatusCode(Enum):
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'
    DELETED = 'DELETED'


class VirtualGatewayTlsValidationContextAcmTrust(BaseModel):
    certificateAuthorityArns: VirtualGatewayCertificateAuthorityArns


class VirtualGatewayTlsValidationContextFileTrust(BaseModel):
    certificateChain: FilePath


class VirtualGatewayTlsValidationContextSdsTrust(BaseModel):
    secretName: VirtualGatewaySdsSecretName


class VirtualGatewayTlsValidationContextTrust(BaseModel):
    acm: Optional[VirtualGatewayTlsValidationContextAcmTrust] = None
    file: Optional[VirtualGatewayTlsValidationContextFileTrust] = None
    sds: Optional[VirtualGatewayTlsValidationContextSdsTrust] = None


class VirtualNodeGrpcConnectionPool(BaseModel):
    maxRequests: MaxRequests


class VirtualNodeHttp2ConnectionPool(BaseModel):
    maxRequests: MaxRequests


class VirtualNodeHttpConnectionPool(BaseModel):
    maxConnections: MaxConnections
    maxPendingRequests: Optional[MaxPendingRequests] = None


class VirtualNodeRef(BaseModel):
    arn: Arn
    createdAt: Timestamp
    lastUpdatedAt: Timestamp
    meshName: ResourceName
    meshOwner: AccountId
    resourceOwner: AccountId
    version: Long
    virtualNodeName: ResourceName


class VirtualNodeServiceProvider(BaseModel):
    virtualNodeName: ResourceName


class VirtualNodeStatusCode(Enum):
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'
    DELETED = 'DELETED'


class VirtualNodeTcpConnectionPool(BaseModel):
    maxConnections: MaxConnections


class VirtualRouterRef(BaseModel):
    arn: Arn
    createdAt: Timestamp
    lastUpdatedAt: Timestamp
    meshName: ResourceName
    meshOwner: AccountId
    resourceOwner: AccountId
    version: Long
    virtualRouterName: ResourceName


class VirtualRouterServiceProvider(BaseModel):
    virtualRouterName: ResourceName


class VirtualRouterStatusCode(Enum):
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'
    DELETED = 'DELETED'


class VirtualServiceProvider(BaseModel):
    virtualNode: Optional[VirtualNodeServiceProvider] = None
    virtualRouter: Optional[VirtualRouterServiceProvider] = None


class VirtualServiceRef(BaseModel):
    arn: Arn
    createdAt: Timestamp
    lastUpdatedAt: Timestamp
    meshName: ResourceName
    meshOwner: AccountId
    resourceOwner: AccountId
    version: Long
    virtualServiceName: ServiceName


class VirtualServiceSpec(BaseModel):
    provider: Optional[VirtualServiceProvider] = None


class VirtualServiceStatusCode(Enum):
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'
    DELETED = 'DELETED'


class WeightedTarget(BaseModel):
    port: Optional[ListenerPort] = None
    virtualNode: ResourceName
    weight: PercentInt


class WeightedTargets(RootModel[List[WeightedTarget]]):
    root: List[WeightedTarget] = Field(..., max_length=10, min_length=1)


class Spec12(BaseModel):
    provider: Optional[VirtualServiceProvider] = None


class V20190125MeshesMeshNameVirtualServicesVirtualServiceNamePutRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    spec: Spec12 = Field(
        ...,
        description='An object that represents the specification of a virtual service.',
    )


class V20190125UntagResourceArnPutRequest(BaseModel):
    tagKeys: List[TagKey] = Field(
        ...,
        description='The keys of the tags to be removed.',
        max_length=50,
        min_length=0,
    )


class AwsCloudMapInstanceAttribute(BaseModel):
    key: AwsCloudMapInstanceAttributeKey
    value: AwsCloudMapInstanceAttributeValue


class AwsCloudMapInstanceAttributes(RootModel[List[AwsCloudMapInstanceAttribute]]):
    root: List[AwsCloudMapInstanceAttribute]


class AwsCloudMapServiceDiscovery(BaseModel):
    attributes: Optional[AwsCloudMapInstanceAttributes] = None
    ipPreference: Optional[IpPreference] = None
    namespaceName: AwsCloudMapName
    serviceName: AwsCloudMapName


class DnsServiceDiscovery(BaseModel):
    hostname: Hostname
    ipPreference: Optional[IpPreference] = None
    responseType: Optional[DnsResponseType] = None


class Duration(BaseModel):
    unit: Optional[DurationUnit] = None
    value: Optional[DurationValue] = None


class EgressFilter(BaseModel):
    type: EgressFilterType


class GatewayRouteHostnameMatch(BaseModel):
    exact: Optional[ExactHostName] = None
    suffix: Optional[SuffixHostname] = None


class GatewayRouteRef(BaseModel):
    arn: Arn
    createdAt: Timestamp
    gatewayRouteName: ResourceName
    lastUpdatedAt: Timestamp
    meshName: ResourceName
    meshOwner: AccountId
    resourceOwner: AccountId
    version: Long
    virtualGatewayName: ResourceName


class GatewayRouteStatus(BaseModel):
    status: GatewayRouteStatusCode


class GatewayRouteVirtualService(BaseModel):
    virtualServiceName: ResourceName


class GrpcMetadataMatchMethod(BaseModel):
    exact: Optional[HeaderMatch] = None
    prefix: Optional[HeaderMatch] = None
    range: Optional[MatchRange] = None
    regex: Optional[HeaderMatch] = None
    suffix: Optional[HeaderMatch] = None


class GrpcRetryPolicy(BaseModel):
    grpcRetryEvents: Optional[GrpcRetryPolicyEvents] = None
    httpRetryEvents: Optional[HttpRetryPolicyEvents] = None
    maxRetries: MaxRetries
    perRetryTimeout: Duration
    tcpRetryEvents: Optional[TcpRetryPolicyEvents] = None


class GrpcRouteAction(BaseModel):
    weightedTargets: WeightedTargets


class GrpcRouteMetadataMatchMethod(BaseModel):
    exact: Optional[HeaderMatch] = None
    prefix: Optional[HeaderMatch] = None
    range: Optional[MatchRange] = None
    regex: Optional[HeaderMatch] = None
    suffix: Optional[HeaderMatch] = None


class GrpcTimeout(BaseModel):
    idle: Optional[Duration] = None
    perRequest: Optional[Duration] = None


class HeaderMatchMethod(BaseModel):
    exact: Optional[HeaderMatch] = None
    prefix: Optional[HeaderMatch] = None
    range: Optional[MatchRange] = None
    regex: Optional[HeaderMatch] = None
    suffix: Optional[HeaderMatch] = None


class HealthCheckPolicy(BaseModel):
    healthyThreshold: HealthCheckThreshold
    intervalMillis: HealthCheckIntervalMillis
    path: Optional[String] = None
    port: Optional[PortNumber] = None
    protocol: PortProtocol
    timeoutMillis: HealthCheckTimeoutMillis
    unhealthyThreshold: HealthCheckThreshold


class HttpGatewayRouteHeader(BaseModel):
    invert: Optional[Boolean] = None
    match: Optional[HeaderMatchMethod] = None
    name: HeaderName


class HttpGatewayRouteHeaders(RootModel[List[HttpGatewayRouteHeader]]):
    root: List[HttpGatewayRouteHeader] = Field(..., max_length=10, min_length=1)


class HttpGatewayRoutePathRewrite(BaseModel):
    exact: Optional[HttpPathExact] = None


class HttpGatewayRouteRewrite(BaseModel):
    hostname: Optional[GatewayRouteHostnameRewrite] = None
    path: Optional[HttpGatewayRoutePathRewrite] = None
    prefix: Optional[HttpGatewayRoutePrefixRewrite] = None


class HttpPathMatch(BaseModel):
    exact: Optional[HttpPathExact] = None
    regex: Optional[HttpPathRegex] = None


class HttpRetryPolicy(BaseModel):
    httpRetryEvents: Optional[HttpRetryPolicyEvents] = None
    maxRetries: MaxRetries
    perRetryTimeout: Duration
    tcpRetryEvents: Optional[TcpRetryPolicyEvents] = None


class HttpRouteAction(BaseModel):
    weightedTargets: WeightedTargets


class HttpRouteHeader(BaseModel):
    invert: Optional[Boolean] = None
    match: Optional[HeaderMatchMethod] = None
    name: HeaderName


class HttpRouteHeaders(RootModel[List[HttpRouteHeader]]):
    root: List[HttpRouteHeader] = Field(..., max_length=10, min_length=1)


class HttpTimeout(BaseModel):
    idle: Optional[Duration] = None
    perRequest: Optional[Duration] = None


class JsonFormatRef(BaseModel):
    key: JsonKey
    value: JsonValue


class ListenerTlsSdsCertificate(BaseModel):
    secretName: SdsSecretName


class ListenerTlsValidationContextTrust(BaseModel):
    file: Optional[TlsValidationContextFileTrust] = None
    sds: Optional[TlsValidationContextSdsTrust] = None


class MeshRef(BaseModel):
    arn: Arn
    createdAt: Timestamp
    lastUpdatedAt: Timestamp
    meshName: ResourceName
    meshOwner: AccountId
    resourceOwner: AccountId
    version: Long


class MeshSpec(BaseModel):
    egressFilter: Optional[EgressFilter] = None
    serviceDiscovery: Optional[MeshServiceDiscovery] = None


class MeshStatus(BaseModel):
    status: Optional[MeshStatusCode] = None


class OutlierDetection(BaseModel):
    baseEjectionDuration: Duration
    interval: Duration
    maxEjectionPercent: OutlierDetectionMaxEjectionPercent
    maxServerErrors: OutlierDetectionMaxServerErrors


class PortMapping(BaseModel):
    port: PortNumber
    protocol: PortProtocol


class QueryParameterMatch(BaseModel):
    exact: Optional[String] = None


class ResourceMetadata(BaseModel):
    arn: Arn
    createdAt: Timestamp
    lastUpdatedAt: Timestamp
    meshOwner: AccountId
    resourceOwner: AccountId
    uid: String
    version: Long


class RouteRef(BaseModel):
    arn: Arn
    createdAt: Timestamp
    lastUpdatedAt: Timestamp
    meshName: ResourceName
    meshOwner: AccountId
    resourceOwner: AccountId
    routeName: ResourceName
    version: Long
    virtualRouterName: ResourceName


class RouteStatus(BaseModel):
    status: RouteStatusCode


class ServiceDiscovery(BaseModel):
    awsCloudMap: Optional[AwsCloudMapServiceDiscovery] = None
    dns: Optional[DnsServiceDiscovery] = None


class TagRef(BaseModel):
    key: TagKey
    value: TagValue


class TcpRouteAction(BaseModel):
    weightedTargets: WeightedTargets


class TcpTimeout(BaseModel):
    idle: Optional[Duration] = None


class TlsValidationContext(BaseModel):
    subjectAlternativeNames: Optional[SubjectAlternativeNames] = None
    trust: TlsValidationContextTrust


class UpdateMeshInput(BaseModel):
    clientToken: Optional[String] = None
    spec: Optional[MeshSpec] = None


class UpdateVirtualServiceInput(BaseModel):
    clientToken: Optional[String] = None
    spec: VirtualServiceSpec


class VirtualGatewayConnectionPool(BaseModel):
    grpc: Optional[VirtualGatewayGrpcConnectionPool] = None
    http: Optional[VirtualGatewayHttpConnectionPool] = None
    http2: Optional[VirtualGatewayHttp2ConnectionPool] = None


class VirtualGatewayHealthCheckPolicy(BaseModel):
    healthyThreshold: VirtualGatewayHealthCheckThreshold
    intervalMillis: VirtualGatewayHealthCheckIntervalMillis
    path: Optional[String] = None
    port: Optional[PortNumber] = None
    protocol: VirtualGatewayPortProtocol
    timeoutMillis: VirtualGatewayHealthCheckTimeoutMillis
    unhealthyThreshold: VirtualGatewayHealthCheckThreshold


class VirtualGatewayList(RootModel[List[VirtualGatewayRef]]):
    root: List[VirtualGatewayRef]


class VirtualGatewayListenerTlsSdsCertificate(BaseModel):
    secretName: VirtualGatewaySdsSecretName


class VirtualGatewayListenerTlsValidationContextTrust(BaseModel):
    file: Optional[VirtualGatewayTlsValidationContextFileTrust] = None
    sds: Optional[VirtualGatewayTlsValidationContextSdsTrust] = None


class VirtualGatewayPortMapping(BaseModel):
    port: PortNumber
    protocol: VirtualGatewayPortProtocol


class VirtualGatewayStatus(BaseModel):
    status: VirtualGatewayStatusCode


class VirtualGatewayTlsValidationContext(BaseModel):
    subjectAlternativeNames: Optional[SubjectAlternativeNames] = None
    trust: VirtualGatewayTlsValidationContextTrust


class VirtualNodeConnectionPool(BaseModel):
    grpc: Optional[VirtualNodeGrpcConnectionPool] = None
    http: Optional[VirtualNodeHttpConnectionPool] = None
    http2: Optional[VirtualNodeHttp2ConnectionPool] = None
    tcp: Optional[VirtualNodeTcpConnectionPool] = None


class VirtualNodeList(RootModel[List[VirtualNodeRef]]):
    root: List[VirtualNodeRef]


class VirtualNodeStatus(BaseModel):
    status: VirtualNodeStatusCode


class VirtualRouterList(RootModel[List[VirtualRouterRef]]):
    root: List[VirtualRouterRef]


class VirtualRouterListener(BaseModel):
    portMapping: PortMapping


class VirtualRouterListeners(RootModel[List[VirtualRouterListener]]):
    root: List[VirtualRouterListener]


class VirtualRouterSpec(BaseModel):
    listeners: Optional[VirtualRouterListeners] = None


class VirtualRouterStatus(BaseModel):
    status: VirtualRouterStatusCode


class VirtualServiceList(RootModel[List[VirtualServiceRef]]):
    root: List[VirtualServiceRef]


class VirtualServiceStatus(BaseModel):
    status: VirtualServiceStatusCode


class Spec(BaseModel):
    egressFilter: Optional[EgressFilter] = None
    serviceDiscovery: Optional[MeshServiceDiscovery] = None


class V20190125MeshesPutRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    meshName: constr(min_length=1, max_length=255) = Field(
        ..., description='The name to use for the service mesh.'
    )
    spec: Optional[Spec] = Field(
        None,
        description='An object that represents the specification of a service mesh.',
    )
    tags: Optional[List[TagRef]] = Field(
        None,
        description='Optional metadata that you can apply to the service mesh to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.',
        max_length=50,
        min_length=0,
    )


class V20190125MeshesMeshNamePutRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    spec: Optional[Spec] = Field(
        None,
        description='An object that represents the specification of a service mesh.',
    )


class Spec10(BaseModel):
    listeners: Optional[VirtualRouterListeners] = None


class V20190125MeshesMeshNameVirtualRoutersPutRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    spec: Spec10 = Field(
        ...,
        description='An object that represents the specification of a virtual router.',
    )
    tags: Optional[List[TagRef]] = Field(
        None,
        description='Optional metadata that you can apply to the virtual router to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.',
        max_length=50,
        min_length=0,
    )
    virtualRouterName: constr(min_length=1, max_length=255) = Field(
        ..., description='The name to use for the virtual router.'
    )


class V20190125MeshesMeshNameVirtualRoutersVirtualRouterNamePutRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    spec: Spec10 = Field(
        ...,
        description='An object that represents the specification of a virtual router.',
    )


class V20190125MeshesMeshNameVirtualServicesPutRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    spec: Spec12 = Field(
        ...,
        description='An object that represents the specification of a virtual service.',
    )
    tags: Optional[List[TagRef]] = Field(
        None,
        description='Optional metadata that you can apply to the virtual service to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.',
        max_length=50,
        min_length=0,
    )
    virtualServiceName: str = Field(
        ..., description='The name to use for the virtual service.'
    )


class V20190125TagResourceArnPutRequest(BaseModel):
    tags: List[TagRef] = Field(
        ...,
        description='The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.',
        max_length=50,
        min_length=0,
    )


class ClientTlsCertificate(BaseModel):
    file: Optional[ListenerTlsFileCertificate] = None
    sds: Optional[ListenerTlsSdsCertificate] = None


class GatewayRouteList(RootModel[List[GatewayRouteRef]]):
    root: List[GatewayRouteRef]


class GatewayRouteTarget(BaseModel):
    port: Optional[ListenerPort] = None
    virtualService: GatewayRouteVirtualService


class GrpcGatewayRouteAction(BaseModel):
    rewrite: Optional[GrpcGatewayRouteRewrite] = None
    target: GatewayRouteTarget


class GrpcGatewayRouteMetadata(BaseModel):
    invert: Optional[Boolean] = None
    match: Optional[GrpcMetadataMatchMethod] = None
    name: HeaderName


class GrpcGatewayRouteMetadataList(RootModel[List[GrpcGatewayRouteMetadata]]):
    root: List[GrpcGatewayRouteMetadata] = Field(..., max_length=10, min_length=1)


class GrpcRouteMetadata(BaseModel):
    invert: Optional[Boolean] = None
    match: Optional[GrpcRouteMetadataMatchMethod] = None
    name: HeaderName


class GrpcRouteMetadataList(RootModel[List[GrpcRouteMetadata]]):
    root: List[GrpcRouteMetadata] = Field(..., max_length=10, min_length=1)


class HttpGatewayRouteAction(BaseModel):
    rewrite: Optional[HttpGatewayRouteRewrite] = None
    target: GatewayRouteTarget


class HttpQueryParameter(BaseModel):
    match: Optional[QueryParameterMatch] = None
    name: QueryParameterName


class HttpQueryParameters(RootModel[List[HttpQueryParameter]]):
    root: List[HttpQueryParameter] = Field(..., max_length=10, min_length=1)


class HttpRouteMatch(BaseModel):
    headers: Optional[HttpRouteHeaders] = None
    method: Optional[HttpMethod] = None
    path: Optional[HttpPathMatch] = None
    port: Optional[ListenerPort] = None
    prefix: Optional[String] = None
    queryParameters: Optional[HttpQueryParameters] = None
    scheme: Optional[HttpScheme] = None


class JsonFormat(RootModel[List[JsonFormatRef]]):
    root: List[JsonFormatRef]


class ListGatewayRoutesOutput(BaseModel):
    gatewayRoutes: GatewayRouteList
    nextToken: Optional[String] = None


class ListVirtualGatewaysOutput(BaseModel):
    nextToken: Optional[String] = None
    virtualGateways: VirtualGatewayList


class ListVirtualNodesOutput(BaseModel):
    nextToken: Optional[String] = None
    virtualNodes: VirtualNodeList


class ListVirtualRoutersOutput(BaseModel):
    nextToken: Optional[String] = None
    virtualRouters: VirtualRouterList


class ListVirtualServicesOutput(BaseModel):
    nextToken: Optional[String] = None
    virtualServices: VirtualServiceList


class ListenerTimeout(BaseModel):
    grpc: Optional[GrpcTimeout] = None
    http: Optional[HttpTimeout] = None
    http2: Optional[HttpTimeout] = None
    tcp: Optional[TcpTimeout] = None


class ListenerTlsCertificate(BaseModel):
    acm: Optional[ListenerTlsAcmCertificate] = None
    file: Optional[ListenerTlsFileCertificate] = None
    sds: Optional[ListenerTlsSdsCertificate] = None


class ListenerTlsValidationContext(BaseModel):
    subjectAlternativeNames: Optional[SubjectAlternativeNames] = None
    trust: ListenerTlsValidationContextTrust


class LoggingFormat(BaseModel):
    json_: Optional[JsonFormat] = Field(None, alias='json')
    text: Optional[TextFormat] = None


class MeshData(BaseModel):
    meshName: ResourceName
    metadata: ResourceMetadata
    spec: MeshSpec
    status: MeshStatus


class MeshList(RootModel[List[MeshRef]]):
    root: List[MeshRef]


class RouteList(RootModel[List[RouteRef]]):
    root: List[RouteRef]


class TagList(RootModel[List[TagRef]]):
    root: List[TagRef] = Field(..., max_length=50, min_length=0)


class TagResourceInput(BaseModel):
    tags: TagList


class TcpRoute(BaseModel):
    action: TcpRouteAction
    match: Optional[TcpRouteMatch] = None
    timeout: Optional[TcpTimeout] = None


class UpdateMeshOutput(BaseModel):
    mesh: MeshData


class UpdateVirtualRouterInput(BaseModel):
    clientToken: Optional[String] = None
    spec: VirtualRouterSpec


class VirtualGatewayClientTlsCertificate(BaseModel):
    file: Optional[VirtualGatewayListenerTlsFileCertificate] = None
    sds: Optional[VirtualGatewayListenerTlsSdsCertificate] = None


class VirtualGatewayFileAccessLog(BaseModel):
    format: Optional[LoggingFormat] = None
    path: FilePath


class VirtualGatewayListenerTlsCertificate(BaseModel):
    acm: Optional[VirtualGatewayListenerTlsAcmCertificate] = None
    file: Optional[VirtualGatewayListenerTlsFileCertificate] = None
    sds: Optional[VirtualGatewayListenerTlsSdsCertificate] = None


class VirtualGatewayListenerTlsValidationContext(BaseModel):
    subjectAlternativeNames: Optional[SubjectAlternativeNames] = None
    trust: VirtualGatewayListenerTlsValidationContextTrust


class VirtualRouterData(BaseModel):
    meshName: ResourceName
    metadata: ResourceMetadata
    spec: VirtualRouterSpec
    status: VirtualRouterStatus
    virtualRouterName: ResourceName


class VirtualServiceData(BaseModel):
    meshName: ResourceName
    metadata: ResourceMetadata
    spec: VirtualServiceSpec
    status: VirtualServiceStatus
    virtualServiceName: ServiceName


class ClientPolicyTls(BaseModel):
    certificate: Optional[ClientTlsCertificate] = None
    enforce: Optional[Boolean] = None
    ports: Optional[PortSet] = None
    validation: TlsValidationContext


class CreateMeshInput(BaseModel):
    clientToken: Optional[String] = None
    meshName: ResourceName
    spec: Optional[MeshSpec] = None
    tags: Optional[TagList] = None


class CreateMeshOutput(BaseModel):
    mesh: MeshData


class CreateVirtualRouterInput(BaseModel):
    clientToken: Optional[String] = None
    spec: VirtualRouterSpec
    tags: Optional[TagList] = None
    virtualRouterName: ResourceName


class CreateVirtualRouterOutput(BaseModel):
    virtualRouter: VirtualRouterData


class CreateVirtualServiceInput(BaseModel):
    clientToken: Optional[String] = None
    spec: VirtualServiceSpec
    tags: Optional[TagList] = None
    virtualServiceName: ServiceName


class CreateVirtualServiceOutput(BaseModel):
    virtualService: VirtualServiceData


class DeleteMeshOutput(BaseModel):
    mesh: MeshData


class DeleteVirtualRouterOutput(BaseModel):
    virtualRouter: VirtualRouterData


class DeleteVirtualServiceOutput(BaseModel):
    virtualService: VirtualServiceData


class DescribeMeshOutput(BaseModel):
    mesh: MeshData


class DescribeVirtualRouterOutput(BaseModel):
    virtualRouter: VirtualRouterData


class DescribeVirtualServiceOutput(BaseModel):
    virtualService: VirtualServiceData


class FileAccessLog(BaseModel):
    format: Optional[LoggingFormat] = None
    path: FilePath


class GrpcGatewayRouteMatch(BaseModel):
    hostname: Optional[GatewayRouteHostnameMatch] = None
    metadata: Optional[GrpcGatewayRouteMetadataList] = None
    port: Optional[ListenerPort] = None
    serviceName: Optional[ServiceName] = None


class GrpcRouteMatch(BaseModel):
    metadata: Optional[GrpcRouteMetadataList] = None
    methodName: Optional[MethodName] = None
    port: Optional[ListenerPort] = None
    serviceName: Optional[ServiceName] = None


class HttpGatewayRouteMatch(BaseModel):
    headers: Optional[HttpGatewayRouteHeaders] = None
    hostname: Optional[GatewayRouteHostnameMatch] = None
    method: Optional[HttpMethod] = None
    path: Optional[HttpPathMatch] = None
    port: Optional[ListenerPort] = None
    prefix: Optional[String] = None
    queryParameters: Optional[HttpQueryParameters] = None


class HttpRoute(BaseModel):
    action: HttpRouteAction
    match: HttpRouteMatch
    retryPolicy: Optional[HttpRetryPolicy] = None
    timeout: Optional[HttpTimeout] = None


class ListMeshesOutput(BaseModel):
    meshes: MeshList
    nextToken: Optional[String] = None


class ListRoutesOutput(BaseModel):
    nextToken: Optional[String] = None
    routes: RouteList


class ListTagsForResourceOutput(BaseModel):
    nextToken: Optional[String] = None
    tags: TagList


class ListenerTls(BaseModel):
    certificate: ListenerTlsCertificate
    mode: ListenerTlsMode
    validation: Optional[ListenerTlsValidationContext] = None


class UpdateVirtualRouterOutput(BaseModel):
    virtualRouter: VirtualRouterData


class UpdateVirtualServiceOutput(BaseModel):
    virtualService: VirtualServiceData


class VirtualGatewayAccessLog(BaseModel):
    file: Optional[VirtualGatewayFileAccessLog] = None


class VirtualGatewayClientPolicyTls(BaseModel):
    certificate: Optional[VirtualGatewayClientTlsCertificate] = None
    enforce: Optional[Boolean] = None
    ports: Optional[PortSet] = None
    validation: VirtualGatewayTlsValidationContext


class VirtualGatewayListenerTls(BaseModel):
    certificate: VirtualGatewayListenerTlsCertificate
    mode: VirtualGatewayListenerTlsMode
    validation: Optional[VirtualGatewayListenerTlsValidationContext] = None


class VirtualGatewayLogging(BaseModel):
    accessLog: Optional[VirtualGatewayAccessLog] = None


class AccessLog(BaseModel):
    file: Optional[FileAccessLog] = None


class ClientPolicy(BaseModel):
    tls: Optional[ClientPolicyTls] = None


class GrpcGatewayRoute(BaseModel):
    action: GrpcGatewayRouteAction
    match: GrpcGatewayRouteMatch


class GrpcRoute(BaseModel):
    action: GrpcRouteAction
    match: GrpcRouteMatch
    retryPolicy: Optional[GrpcRetryPolicy] = None
    timeout: Optional[GrpcTimeout] = None


class HttpGatewayRoute(BaseModel):
    action: HttpGatewayRouteAction
    match: HttpGatewayRouteMatch


class Listener(BaseModel):
    connectionPool: Optional[VirtualNodeConnectionPool] = None
    healthCheck: Optional[HealthCheckPolicy] = None
    outlierDetection: Optional[OutlierDetection] = None
    portMapping: PortMapping
    timeout: Optional[ListenerTimeout] = None
    tls: Optional[ListenerTls] = None


class Listeners(RootModel[List[Listener]]):
    root: List[Listener]


class Logging(BaseModel):
    accessLog: Optional[AccessLog] = None


class RouteSpec(BaseModel):
    grpcRoute: Optional[GrpcRoute] = None
    http2Route: Optional[HttpRoute] = None
    httpRoute: Optional[HttpRoute] = None
    priority: Optional[RoutePriority] = None
    tcpRoute: Optional[TcpRoute] = None


class UpdateRouteInput(BaseModel):
    clientToken: Optional[String] = None
    spec: RouteSpec


class VirtualGatewayClientPolicy(BaseModel):
    tls: Optional[VirtualGatewayClientPolicyTls] = None


class VirtualGatewayListener(BaseModel):
    connectionPool: Optional[VirtualGatewayConnectionPool] = None
    healthCheck: Optional[VirtualGatewayHealthCheckPolicy] = None
    portMapping: VirtualGatewayPortMapping
    tls: Optional[VirtualGatewayListenerTls] = None


class VirtualGatewayListeners(RootModel[List[VirtualGatewayListener]]):
    root: List[VirtualGatewayListener]


class VirtualServiceBackend(BaseModel):
    clientPolicy: Optional[ClientPolicy] = None
    virtualServiceName: ServiceName


class Spec2(BaseModel):
    grpcRoute: Optional[GrpcGatewayRoute] = None
    http2Route: Optional[HttpGatewayRoute] = None
    httpRoute: Optional[HttpGatewayRoute] = None
    priority: Optional[GatewayRoutePriority] = None


class V20190125MeshesMeshNameVirtualGatewayVirtualGatewayNameGatewayRoutesPutRequest(
    BaseModel
):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    gatewayRouteName: constr(min_length=1, max_length=255) = Field(
        ..., description='The name to use for the gateway route.'
    )
    spec: Spec2 = Field(
        ...,
        description='An object that represents a gateway route specification. Specify one gateway route type.',
    )
    tags: Optional[List[TagRef]] = Field(
        None,
        description='Optional metadata that you can apply to the gateway route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.',
        max_length=50,
        min_length=0,
    )


class V20190125MeshesMeshNameVirtualGatewayVirtualGatewayNameGatewayRoutesGatewayRouteNamePutRequest(
    BaseModel
):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    spec: Spec2 = Field(
        ...,
        description='An object that represents a gateway route specification. Specify one gateway route type.',
    )


class Spec8(BaseModel):
    grpcRoute: Optional[GrpcRoute] = None
    http2Route: Optional[HttpRoute] = None
    httpRoute: Optional[HttpRoute] = None
    priority: Optional[RoutePriority] = None
    tcpRoute: Optional[TcpRoute] = None


class V20190125MeshesMeshNameVirtualRouterVirtualRouterNameRoutesPutRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    routeName: constr(min_length=1, max_length=255) = Field(
        ..., description='The name to use for the route.'
    )
    spec: Spec8 = Field(
        ...,
        description='An object that represents a route specification. Specify one route type.',
    )
    tags: Optional[List[TagRef]] = Field(
        None,
        description='Optional metadata that you can apply to the route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.',
        max_length=50,
        min_length=0,
    )


class V20190125MeshesMeshNameVirtualRouterVirtualRouterNameRoutesRouteNamePutRequest(
    BaseModel
):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    spec: Spec8 = Field(
        ...,
        description='An object that represents a route specification. Specify one route type.',
    )


class Backend(BaseModel):
    virtualService: Optional[VirtualServiceBackend] = None


class BackendDefaults(BaseModel):
    clientPolicy: Optional[ClientPolicy] = None


class Backends(RootModel[List[Backend]]):
    root: List[Backend]


class CreateRouteInput(BaseModel):
    clientToken: Optional[String] = None
    routeName: ResourceName
    spec: RouteSpec
    tags: Optional[TagList] = None


class GatewayRouteSpec(BaseModel):
    grpcRoute: Optional[GrpcGatewayRoute] = None
    http2Route: Optional[HttpGatewayRoute] = None
    httpRoute: Optional[HttpGatewayRoute] = None
    priority: Optional[GatewayRoutePriority] = None


class RouteData(BaseModel):
    meshName: ResourceName
    metadata: ResourceMetadata
    routeName: ResourceName
    spec: RouteSpec
    status: RouteStatus
    virtualRouterName: ResourceName


class UpdateGatewayRouteInput(BaseModel):
    clientToken: Optional[String] = None
    spec: GatewayRouteSpec


class UpdateRouteOutput(BaseModel):
    route: RouteData


class VirtualGatewayBackendDefaults(BaseModel):
    clientPolicy: Optional[VirtualGatewayClientPolicy] = None


class VirtualGatewaySpec(BaseModel):
    backendDefaults: Optional[VirtualGatewayBackendDefaults] = None
    listeners: VirtualGatewayListeners
    logging: Optional[VirtualGatewayLogging] = None


class VirtualNodeSpec(BaseModel):
    backendDefaults: Optional[BackendDefaults] = None
    backends: Optional[Backends] = None
    listeners: Optional[Listeners] = None
    logging: Optional[Logging] = None
    serviceDiscovery: Optional[ServiceDiscovery] = None


class Spec4(BaseModel):
    backendDefaults: Optional[VirtualGatewayBackendDefaults] = None
    listeners: Optional[VirtualGatewayListeners] = None
    logging: Optional[VirtualGatewayLogging] = None


class V20190125MeshesMeshNameVirtualGatewaysPutRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    spec: Spec4 = Field(
        ...,
        description='An object that represents the specification of a service mesh resource.',
    )
    tags: Optional[List[TagRef]] = Field(
        None,
        description='Optional metadata that you can apply to the virtual gateway to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.',
        max_length=50,
        min_length=0,
    )
    virtualGatewayName: constr(min_length=1, max_length=255) = Field(
        ..., description='The name to use for the virtual gateway.'
    )


class V20190125MeshesMeshNameVirtualGatewaysVirtualGatewayNamePutRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    spec: Spec4 = Field(
        ...,
        description='An object that represents the specification of a service mesh resource.',
    )


class Spec6(BaseModel):
    backendDefaults: Optional[BackendDefaults] = None
    backends: Optional[Backends] = None
    listeners: Optional[Listeners] = None
    logging: Optional[Logging] = None
    serviceDiscovery: Optional[ServiceDiscovery] = None


class V20190125MeshesMeshNameVirtualNodesPutRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    spec: Spec6 = Field(
        ...,
        description='An object that represents the specification of a virtual node.',
    )
    tags: Optional[List[TagRef]] = Field(
        None,
        description='Optional metadata that you can apply to the virtual node to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.',
        max_length=50,
        min_length=0,
    )
    virtualNodeName: constr(min_length=1, max_length=255) = Field(
        ..., description='The name to use for the virtual node.'
    )


class V20190125MeshesMeshNameVirtualNodesVirtualNodeNamePutRequest(BaseModel):
    clientToken: Optional[str] = Field(
        None,
        description='Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.',
    )
    spec: Spec6 = Field(
        ...,
        description='An object that represents the specification of a virtual node.',
    )


class CreateGatewayRouteInput(BaseModel):
    clientToken: Optional[String] = None
    gatewayRouteName: ResourceName
    spec: GatewayRouteSpec
    tags: Optional[TagList] = None


class CreateRouteOutput(BaseModel):
    route: RouteData


class CreateVirtualGatewayInput(BaseModel):
    clientToken: Optional[String] = None
    spec: VirtualGatewaySpec
    tags: Optional[TagList] = None
    virtualGatewayName: ResourceName


class CreateVirtualNodeInput(BaseModel):
    clientToken: Optional[String] = None
    spec: VirtualNodeSpec
    tags: Optional[TagList] = None
    virtualNodeName: ResourceName


class DeleteRouteOutput(BaseModel):
    route: RouteData


class DescribeRouteOutput(BaseModel):
    route: RouteData


class GatewayRouteData(BaseModel):
    gatewayRouteName: ResourceName
    meshName: ResourceName
    metadata: ResourceMetadata
    spec: GatewayRouteSpec
    status: GatewayRouteStatus
    virtualGatewayName: ResourceName


class UpdateGatewayRouteOutput(BaseModel):
    gatewayRoute: GatewayRouteData


class UpdateVirtualGatewayInput(BaseModel):
    clientToken: Optional[String] = None
    spec: VirtualGatewaySpec


class UpdateVirtualNodeInput(BaseModel):
    clientToken: Optional[String] = None
    spec: VirtualNodeSpec


class VirtualGatewayData(BaseModel):
    meshName: ResourceName
    metadata: ResourceMetadata
    spec: VirtualGatewaySpec
    status: VirtualGatewayStatus
    virtualGatewayName: ResourceName


class VirtualNodeData(BaseModel):
    meshName: ResourceName
    metadata: ResourceMetadata
    spec: VirtualNodeSpec
    status: VirtualNodeStatus
    virtualNodeName: ResourceName


class CreateGatewayRouteOutput(BaseModel):
    gatewayRoute: GatewayRouteData


class CreateVirtualGatewayOutput(BaseModel):
    virtualGateway: VirtualGatewayData


class CreateVirtualNodeOutput(BaseModel):
    virtualNode: VirtualNodeData


class DeleteGatewayRouteOutput(BaseModel):
    gatewayRoute: GatewayRouteData


class DeleteVirtualGatewayOutput(BaseModel):
    virtualGateway: VirtualGatewayData


class DeleteVirtualNodeOutput(BaseModel):
    virtualNode: VirtualNodeData


class DescribeGatewayRouteOutput(BaseModel):
    gatewayRoute: GatewayRouteData


class DescribeVirtualGatewayOutput(BaseModel):
    virtualGateway: VirtualGatewayData


class DescribeVirtualNodeOutput(BaseModel):
    virtualNode: VirtualNodeData


class UpdateVirtualGatewayOutput(BaseModel):
    virtualGateway: VirtualGatewayData


class UpdateVirtualNodeOutput(BaseModel):
    virtualNode: VirtualNodeData
