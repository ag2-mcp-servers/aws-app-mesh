# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T09:41:07+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query
from pydantic import conint, constr

from models import (
    BadRequestException,
    ConflictException,
    CreateGatewayRouteOutput,
    CreateMeshOutput,
    CreateRouteOutput,
    CreateVirtualGatewayOutput,
    CreateVirtualNodeOutput,
    CreateVirtualRouterOutput,
    CreateVirtualServiceOutput,
    DeleteGatewayRouteOutput,
    DeleteMeshOutput,
    DeleteRouteOutput,
    DeleteVirtualGatewayOutput,
    DeleteVirtualNodeOutput,
    DeleteVirtualRouterOutput,
    DeleteVirtualServiceOutput,
    DescribeGatewayRouteOutput,
    DescribeMeshOutput,
    DescribeRouteOutput,
    DescribeVirtualGatewayOutput,
    DescribeVirtualNodeOutput,
    DescribeVirtualRouterOutput,
    DescribeVirtualServiceOutput,
    ForbiddenException,
    InternalServerErrorException,
    LimitExceededException,
    ListGatewayRoutesOutput,
    ListMeshesOutput,
    ListRoutesOutput,
    ListTagsForResourceOutput,
    ListVirtualGatewaysOutput,
    ListVirtualNodesOutput,
    ListVirtualRoutersOutput,
    ListVirtualServicesOutput,
    NotFoundException,
    ResourceInUseException,
    ServiceUnavailableException,
    TagResourceOutput,
    TooManyRequestsException,
    TooManyTagsException,
    UntagResourceOutput,
    UpdateGatewayRouteOutput,
    UpdateMeshOutput,
    UpdateRouteOutput,
    UpdateVirtualGatewayOutput,
    UpdateVirtualNodeOutput,
    UpdateVirtualRouterOutput,
    UpdateVirtualServiceOutput,
    V20190125MeshesMeshNamePutRequest,
    V20190125MeshesMeshNameVirtualGatewaysPutRequest,
    V20190125MeshesMeshNameVirtualGatewaysVirtualGatewayNamePutRequest,
    V20190125MeshesMeshNameVirtualGatewayVirtualGatewayNameGatewayRoutesGatewayRouteNamePutRequest,
    V20190125MeshesMeshNameVirtualGatewayVirtualGatewayNameGatewayRoutesPutRequest,
    V20190125MeshesMeshNameVirtualNodesPutRequest,
    V20190125MeshesMeshNameVirtualNodesVirtualNodeNamePutRequest,
    V20190125MeshesMeshNameVirtualRoutersPutRequest,
    V20190125MeshesMeshNameVirtualRoutersVirtualRouterNamePutRequest,
    V20190125MeshesMeshNameVirtualRouterVirtualRouterNameRoutesPutRequest,
    V20190125MeshesMeshNameVirtualRouterVirtualRouterNameRoutesRouteNamePutRequest,
    V20190125MeshesMeshNameVirtualServicesPutRequest,
    V20190125MeshesMeshNameVirtualServicesVirtualServiceNamePutRequest,
    V20190125MeshesPutRequest,
    V20190125TagResourceArnPutRequest,
    V20190125UntagResourceArnPutRequest,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='<p>App Mesh is a service mesh based on the Envoy proxy that makes it easy to monitor and control microservices. App Mesh standardizes how your microservices communicate, giving you end-to-end visibility and helping to ensure high availability for your applications.</p> <p>App Mesh gives you consistent visibility and network traffic controls for every microservice in an application. You can use App Mesh with Amazon Web Services Fargate, Amazon ECS, Amazon EKS, Kubernetes on Amazon Web Services, and Amazon EC2.</p> <note> <p>App Mesh supports microservice applications that use service discovery naming for their components. For more information about service discovery on Amazon ECS, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html">Service Discovery</a> in the <i>Amazon Elastic Container Service Developer Guide</i>. Kubernetes <code>kube-dns</code> and <code>coredns</code> are supported. For more information, see <a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/">DNS for Services and Pods</a> in the Kubernetes documentation.</p> </note>',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='AWS App Mesh',
    version='2019-01-25',
    servers=[
        {
            'description': 'The AWS App Mesh multi-region endpoint',
            'url': 'http://appmesh.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AWS App Mesh multi-region endpoint',
            'url': 'https://appmesh.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AWS App Mesh endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://appmesh.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The AWS App Mesh endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://appmesh.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/v20190125/meshes',
    description=""" Returns a list of existing service meshes. """,
    tags=[
        'mesh_lifecycle_management',
        'gateway_route_lifecycle_management',
        'virtual_gateway_lifecycle_management',
        'virtual_node_lifecycle_management',
        'virtual_router_route_management',
        'virtual_router_lifecycle_management',
        'virtual_service_lifecycle_management',
        'resource_management_tagging',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_meshes(
    limit: Optional[conint(ge=1, le=100)] = None,
    next_token: Optional[str] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes',
    description=""" <p>Creates a service mesh.</p> <p> A service mesh is a logical boundary for network traffic between services that are represented by resources within the mesh. After you create your service mesh, you can create virtual services, virtual nodes, virtual routers, and routes to distribute traffic between the applications in your mesh.</p> <p>For more information about service meshes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/meshes.html">Service meshes</a>.</p> """,
    tags=['mesh_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_mesh(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v20190125/meshes/{meshName}',
    description=""" <p>Deletes an existing service mesh.</p> <p>You must delete all resources (virtual services, routes, virtual routers, and virtual nodes) in the service mesh before you can delete the mesh itself.</p> """,
    tags=['mesh_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_mesh(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}',
    description=""" Describes an existing service mesh. """,
    tags=['mesh_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_mesh(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}',
    description=""" Updates an existing service mesh. """,
    tags=['mesh_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_mesh(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNamePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes',
    description=""" Returns a list of existing gateway routes that are associated to a virtual gateway. """,
    tags=['virtual_gateway_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_gateway_routes(
    limit: Optional[conint(ge=1, le=100)] = None,
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    virtual_gateway_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualGatewayName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes',
    description=""" <p>Creates a gateway route.</p> <p>A gateway route is attached to a virtual gateway and routes traffic to an existing virtual service. If a route matches a request, it can distribute traffic to a target virtual service.</p> <p>For more information about gateway routes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/gateway-routes.html">Gateway routes</a>.</p> """,
    tags=[
        'mesh_lifecycle_management',
        'gateway_route_lifecycle_management',
        'virtual_gateway_lifecycle_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_gateway_route(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_gateway_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualGatewayName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNameVirtualGatewayVirtualGatewayNameGatewayRoutesPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes/{gatewayRouteName}',
    description=""" Deletes an existing gateway route. """,
    tags=['gateway_route_lifecycle_management', 'virtual_gateway_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_gateway_route(
    gateway_route_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='gatewayRouteName'
    ),
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_gateway_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualGatewayName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes/{gatewayRouteName}',
    description=""" Describes an existing gateway route. """,
    tags=['gateway_route_lifecycle_management', 'virtual_gateway_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_gateway_route(
    gateway_route_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='gatewayRouteName'
    ),
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_gateway_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualGatewayName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes/{gatewayRouteName}',
    description=""" Updates an existing gateway route that is associated to a specified virtual gateway in a service mesh. """,
    tags=['gateway_route_lifecycle_management', 'virtual_gateway_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_gateway_route(
    gateway_route_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='gatewayRouteName'
    ),
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_gateway_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualGatewayName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNameVirtualGatewayVirtualGatewayNameGatewayRoutesGatewayRouteNamePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}/virtualGateways',
    description=""" Returns a list of existing virtual gateways in a service mesh. """,
    tags=['mesh_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_virtual_gateways(
    limit: Optional[conint(ge=1, le=100)] = None,
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}/virtualGateways',
    description=""" <p>Creates a virtual gateway.</p> <p>A virtual gateway allows resources outside your mesh to communicate to resources that are inside your mesh. The virtual gateway represents an Envoy proxy running in an Amazon ECS task, in a Kubernetes service, or on an Amazon EC2 instance. Unlike a virtual node, which represents an Envoy running with an application, a virtual gateway represents Envoy deployed by itself.</p> <p>For more information about virtual gateways, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html">Virtual gateways</a>. </p> """,
    tags=['mesh_lifecycle_management', 'virtual_gateway_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_virtual_gateway(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNameVirtualGatewaysPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v20190125/meshes/{meshName}/virtualGateways/{virtualGatewayName}',
    description=""" Deletes an existing virtual gateway. You cannot delete a virtual gateway if any gateway routes are associated to it. """,
    tags=['mesh_lifecycle_management', 'virtual_gateway_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_virtual_gateway(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_gateway_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualGatewayName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}/virtualGateways/{virtualGatewayName}',
    description=""" Describes an existing virtual gateway. """,
    tags=['mesh_lifecycle_management', 'virtual_gateway_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_virtual_gateway(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_gateway_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualGatewayName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}/virtualGateways/{virtualGatewayName}',
    description=""" Updates an existing virtual gateway in a specified service mesh. """,
    tags=['virtual_gateway_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_virtual_gateway(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_gateway_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualGatewayName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNameVirtualGatewaysVirtualGatewayNamePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}/virtualNodes',
    description=""" Returns a list of existing virtual nodes. """,
    tags=['mesh_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_virtual_nodes(
    limit: Optional[conint(ge=1, le=100)] = None,
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}/virtualNodes',
    description=""" <p>Creates a virtual node within a service mesh.</p> <p> A virtual node acts as a logical pointer to a particular task group, such as an Amazon ECS service or a Kubernetes deployment. When you create a virtual node, you can specify the service discovery information for your task group, and whether the proxy running in a task group will communicate with other proxies using Transport Layer Security (TLS).</p> <p>You define a <code>listener</code> for any inbound traffic that your virtual node expects. Any virtual service that your virtual node expects to communicate to is specified as a <code>backend</code>.</p> <p>The response metadata for your new virtual node contains the <code>arn</code> that is associated with the virtual node. Set this value to the full ARN; for example, <code>arn:aws:appmesh:us-west-2:123456789012:myMesh/default/virtualNode/myApp</code>) as the <code>APPMESH_RESOURCE_ARN</code> environment variable for your task group's Envoy proxy container in your task definition or pod spec. This is then mapped to the <code>node.id</code> and <code>node.cluster</code> Envoy parameters.</p> <note> <p>By default, App Mesh uses the name of the resource you specified in <code>APPMESH_RESOURCE_ARN</code> when Envoy is referring to itself in metrics and traces. You can override this behavior by setting the <code>APPMESH_RESOURCE_CLUSTER</code> environment variable with your own name.</p> </note> <p>For more information about virtual nodes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_nodes.html">Virtual nodes</a>. You must be using <code>1.15.0</code> or later of the Envoy image when setting these variables. For more information aboutApp Mesh Envoy variables, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/envoy.html">Envoy image</a> in the App Mesh User Guide.</p> """,
    tags=['mesh_lifecycle_management', 'virtual_node_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_virtual_node(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNameVirtualNodesPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v20190125/meshes/{meshName}/virtualNodes/{virtualNodeName}',
    description=""" <p>Deletes an existing virtual node.</p> <p>You must delete any virtual services that list a virtual node as a service provider before you can delete the virtual node itself.</p> """,
    tags=['virtual_node_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_virtual_node(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_node_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualNodeName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}/virtualNodes/{virtualNodeName}',
    description=""" Describes an existing virtual node. """,
    tags=['virtual_node_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_virtual_node(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_node_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualNodeName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}/virtualNodes/{virtualNodeName}',
    description=""" Updates an existing virtual node in a specified service mesh. """,
    tags=['virtual_node_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_virtual_node(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_node_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualNodeName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNameVirtualNodesVirtualNodeNamePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes',
    description=""" Returns a list of existing routes in a service mesh. """,
    tags=['virtual_router_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_routes(
    limit: Optional[conint(ge=1, le=100)] = None,
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    virtual_router_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualRouterName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes',
    description=""" <p>Creates a route that is associated with a virtual router.</p> <p> You can route several different protocols and define a retry policy for a route. Traffic can be routed to one or more virtual nodes.</p> <p>For more information about routes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/routes.html">Routes</a>.</p> """,
    tags=['virtual_router_route_management', 'virtual_router_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_route(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_router_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualRouterName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNameVirtualRouterVirtualRouterNameRoutesPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}',
    description=""" Deletes an existing route. """,
    tags=[
        'mesh_lifecycle_management',
        'gateway_route_lifecycle_management',
        'virtual_router_lifecycle_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_route(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    route_name: constr(min_length=1, max_length=255) = Path(..., alias='routeName'),
    virtual_router_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualRouterName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}',
    description=""" Describes an existing route. """,
    tags=[
        'mesh_lifecycle_management',
        'gateway_route_lifecycle_management',
        'virtual_router_lifecycle_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_route(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    route_name: constr(min_length=1, max_length=255) = Path(..., alias='routeName'),
    virtual_router_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualRouterName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}',
    description=""" Updates an existing route for a specified service mesh and virtual router. """,
    tags=['gateway_route_lifecycle_management', 'virtual_router_route_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_route(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    route_name: constr(min_length=1, max_length=255) = Path(..., alias='routeName'),
    virtual_router_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualRouterName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNameVirtualRouterVirtualRouterNameRoutesRouteNamePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}/virtualRouters',
    description=""" Returns a list of existing virtual routers in a service mesh. """,
    tags=['mesh_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_virtual_routers(
    limit: Optional[conint(ge=1, le=100)] = None,
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}/virtualRouters',
    description=""" <p>Creates a virtual router within a service mesh.</p> <p>Specify a <code>listener</code> for any inbound traffic that your virtual router receives. Create a virtual router for each protocol and port that you need to route. Virtual routers handle traffic for one or more virtual services within your mesh. After you create your virtual router, create and associate routes for your virtual router that direct incoming requests to different virtual nodes.</p> <p>For more information about virtual routers, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_routers.html">Virtual routers</a>.</p> """,
    tags=['mesh_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_virtual_router(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNameVirtualRoutersPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v20190125/meshes/{meshName}/virtualRouters/{virtualRouterName}',
    description=""" <p>Deletes an existing virtual router.</p> <p>You must delete any routes associated with the virtual router before you can delete the router itself.</p> """,
    tags=['virtual_router_lifecycle_management', 'mesh_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_virtual_router(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_router_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualRouterName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}/virtualRouters/{virtualRouterName}',
    description=""" Describes an existing virtual router. """,
    tags=['virtual_router_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_virtual_router(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_router_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualRouterName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}/virtualRouters/{virtualRouterName}',
    description=""" Updates an existing virtual router in a specified service mesh. """,
    tags=['virtual_router_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_virtual_router(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_router_name: constr(min_length=1, max_length=255) = Path(
        ..., alias='virtualRouterName'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNameVirtualRoutersVirtualRouterNamePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}/virtualServices',
    description=""" Returns a list of existing virtual services in a service mesh. """,
    tags=['mesh_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_virtual_services(
    limit: Optional[conint(ge=1, le=100)] = None,
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    next_token: Optional[str] = Query(None, alias='nextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}/virtualServices',
    description=""" <p>Creates a virtual service within a service mesh.</p> <p>A virtual service is an abstraction of a real service that is provided by a virtual node directly or indirectly by means of a virtual router. Dependent services call your virtual service by its <code>virtualServiceName</code>, and those requests are routed to the virtual node or virtual router that is specified as the provider for the virtual service.</p> <p>For more information about virtual services, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_services.html">Virtual services</a>.</p> """,
    tags=['mesh_lifecycle_management', 'virtual_service_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_virtual_service(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNameVirtualServicesPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v20190125/meshes/{meshName}/virtualServices/{virtualServiceName}',
    description=""" Deletes an existing virtual service. """,
    tags=['virtual_service_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_virtual_service(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_service_name: str = Path(..., alias='virtualServiceName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/meshes/{meshName}/virtualServices/{virtualServiceName}',
    description=""" Describes an existing virtual service. """,
    tags=['virtual_service_lifecycle_management', 'mesh_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def describe_virtual_service(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_service_name: str = Path(..., alias='virtualServiceName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/meshes/{meshName}/virtualServices/{virtualServiceName}',
    description=""" Updates an existing virtual service in a specified service mesh. """,
    tags=['virtual_service_lifecycle_management', 'mesh_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_virtual_service(
    mesh_name: constr(min_length=1, max_length=255) = Path(..., alias='meshName'),
    mesh_owner: Optional[constr(min_length=12, max_length=12)] = Query(
        None, alias='meshOwner'
    ),
    virtual_service_name: str = Path(..., alias='virtualServiceName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125MeshesMeshNameVirtualServicesVirtualServiceNamePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/tag#resourceArn',
    description=""" Associates the specified tags to a resource with the specified <code>resourceArn</code>. If existing tags on a resource aren't specified in the request parameters, they aren't changed. When a resource is deleted, the tags associated with that resource are also deleted. """,
    tags=['resource_management_tagging'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    resource_arn: str = Query(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125TagResourceArnPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v20190125/tags#resourceArn',
    description=""" List the tags for an App Mesh resource. """,
    tags=['resource_management_tagging'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    limit: Optional[conint(ge=1, le=50)] = None,
    next_token: Optional[str] = Query(None, alias='nextToken'),
    resource_arn: str = Query(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v20190125/untag#resourceArn',
    description=""" Deletes specified tags from a resource. """,
    tags=['resource_management_tagging'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    resource_arn: str = Query(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V20190125UntagResourceArnPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
